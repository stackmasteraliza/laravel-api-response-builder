<?php

namespace Stackmasteraliza\ApiResponse\OpenApi;

use Illuminate\Routing\Route;
use Illuminate\Routing\Router;
use Illuminate\Support\Facades\File;
use ReflectionClass;
use ReflectionMethod;
use Stackmasteraliza\ApiResponse\Attributes\ApiEndpoint;
use Stackmasteraliza\ApiResponse\Attributes\ApiRequest;
use Stackmasteraliza\ApiResponse\Attributes\ApiRequestBody;
use Stackmasteraliza\ApiResponse\Attributes\ApiResponse;

class OpenApiGenerator
{
    protected array $spec = [];
    protected Router $router;

    public function __construct(Router $router)
    {
        $this->router = $router;
    }

    /**
     * Generate the OpenAPI specification.
     */
    public function generate(): array
    {
        $this->initializeSpec();
        $this->processRoutes();

        return $this->spec;
    }

    /**
     * Generate and save to file.
     */
    public function generateToFile(string $path): bool
    {
        $spec = $this->generate();
        $json = json_encode($spec, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);

        return File::put($path, $json) !== false;
    }

    /**
     * Initialize the OpenAPI specification structure.
     */
    protected function initializeSpec(): void
    {
        $this->spec = [
            'openapi' => '3.0.3',
            'info' => [
                'title' => config('api-response.openapi.title', config('app.name', 'API') . ' Documentation'),
                'description' => config('api-response.openapi.description', 'API documentation generated by Laravel API Response Builder'),
                'version' => config('api-response.openapi.version', '1.0.0'),
                'contact' => config('api-response.openapi.contact', []),
                'license' => config('api-response.openapi.license', []),
            ],
            'servers' => config('api-response.openapi.servers', [
                ['url' => config('app.url', 'http://localhost'), 'description' => 'API Server'],
            ]),
            'paths' => [],
            'components' => [
                'schemas' => $this->getDefaultSchemas(),
                'securitySchemes' => config('api-response.openapi.security_schemes', []),
            ],
            'tags' => [],
        ];

        // Remove empty contact/license
        if (empty($this->spec['info']['contact'])) {
            unset($this->spec['info']['contact']);
        }
        if (empty($this->spec['info']['license'])) {
            unset($this->spec['info']['license']);
        }
        if (empty($this->spec['components']['securitySchemes'])) {
            unset($this->spec['components']['securitySchemes']);
        }
    }

    /**
     * Get default schemas for API responses.
     */
    protected function getDefaultSchemas(): array
    {
        return [
            'SuccessResponse' => [
                'type' => 'object',
                'properties' => [
                    'status_code' => ['type' => 'integer', 'example' => 200],
                    'success' => ['type' => 'boolean', 'example' => true],
                    'message' => ['type' => 'string', 'example' => 'Success'],
                    'data' => ['type' => 'object', 'nullable' => true],
                ],
            ],
            'ErrorResponse' => [
                'type' => 'object',
                'properties' => [
                    'status_code' => ['type' => 'integer', 'example' => 400],
                    'success' => ['type' => 'boolean', 'example' => false],
                    'message' => ['type' => 'string', 'example' => 'Error'],
                    'errors' => ['type' => 'object', 'nullable' => true],
                ],
            ],
            'PaginatedResponse' => [
                'type' => 'object',
                'properties' => [
                    'status_code' => ['type' => 'integer', 'example' => 200],
                    'success' => ['type' => 'boolean', 'example' => true],
                    'message' => ['type' => 'string'],
                    'data' => ['type' => 'array', 'items' => ['type' => 'object']],
                    'meta' => [
                        'type' => 'object',
                        'properties' => [
                            'current_page' => ['type' => 'integer'],
                            'per_page' => ['type' => 'integer'],
                            'total' => ['type' => 'integer'],
                            'last_page' => ['type' => 'integer'],
                            'from' => ['type' => 'integer', 'nullable' => true],
                            'to' => ['type' => 'integer', 'nullable' => true],
                            'path' => ['type' => 'string'],
                            'links' => [
                                'type' => 'object',
                                'properties' => [
                                    'first' => ['type' => 'string', 'nullable' => true],
                                    'last' => ['type' => 'string', 'nullable' => true],
                                    'prev' => ['type' => 'string', 'nullable' => true],
                                    'next' => ['type' => 'string', 'nullable' => true],
                                ],
                            ],
                        ],
                    ],
                ],
            ],
            'ValidationErrorResponse' => [
                'type' => 'object',
                'properties' => [
                    'status_code' => ['type' => 'integer', 'example' => 422],
                    'success' => ['type' => 'boolean', 'example' => false],
                    'message' => ['type' => 'string', 'example' => 'Validation failed'],
                    'errors' => [
                        'type' => 'object',
                        'additionalProperties' => [
                            'type' => 'array',
                            'items' => ['type' => 'string'],
                        ],
                    ],
                ],
            ],
        ];
    }

    /**
     * Process all routes and extract documentation.
     */
    protected function processRoutes(): void
    {
        $routes = $this->router->getRoutes();
        $tags = [];
        $prefix = config('api-response.openapi.route_prefix', 'api');

        foreach ($routes as $route) {
            /** @var Route $route */
            $uri = $route->uri();

            // Only process routes with the configured prefix
            if ($prefix && ! str_starts_with($uri, $prefix)) {
                continue;
            }

            // Skip internal routes
            if (str_contains($uri, 'api-docs') || str_contains($uri, 'swagger')) {
                continue;
            }

            $action = $route->getAction();

            // Skip closures
            if (! isset($action['controller'])) {
                continue;
            }

            $controllerAction = $action['controller'];

            if (! str_contains($controllerAction, '@')) {
                continue;
            }

            [$controller, $method] = explode('@', $controllerAction);

            if (! class_exists($controller)) {
                continue;
            }

            try {
                $reflection = new ReflectionMethod($controller, $method);
                $pathSpec = $this->buildPathSpec($route, $reflection);

                if ($pathSpec) {
                    $path = '/' . ltrim($uri, '/');
                    // Convert Laravel route parameters to OpenAPI format
                    $path = preg_replace('/\{(\w+)\?\}/', '{$1}', $path);
                    $path = preg_replace('/\{(\w+)\}/', '{$1}', $path);

                    if (! isset($this->spec['paths'][$path])) {
                        $this->spec['paths'][$path] = [];
                    }

                    foreach ($route->methods() as $httpMethod) {
                        $httpMethod = strtolower($httpMethod);
                        if ($httpMethod === 'head') {
                            continue;
                        }
                        $this->spec['paths'][$path][$httpMethod] = $pathSpec;

                        // Collect tags
                        foreach ($pathSpec['tags'] ?? [] as $tag) {
                            $tags[$tag] = true;
                        }
                    }
                }
            } catch (\ReflectionException $e) {
                continue;
            }
        }

        // Set unique tags
        $this->spec['tags'] = array_map(
            fn($tag) => ['name' => $tag],
            array_keys($tags)
        );
    }

    /**
     * Build the path specification for a route.
     */
    protected function buildPathSpec(Route $route, ReflectionMethod $reflection): ?array
    {
        $attributes = $reflection->getAttributes(ApiEndpoint::class);

        // Auto-generate documentation even without attributes
        $endpoint = null;
        if (! empty($attributes)) {
            $endpoint = $attributes[0]->newInstance();
        }

        $spec = [
            'summary' => $endpoint?->summary ?? $this->generateSummary($reflection),
            'description' => $endpoint?->description ?? $this->generateDescription($reflection),
            'operationId' => $this->generateOperationId($route, $reflection),
            'tags' => $endpoint?->tags ?? $this->inferTags($route),
            'parameters' => $this->extractParameters($route, $reflection),
            'responses' => $this->extractResponses($reflection, $route),
        ];

        if ($endpoint?->deprecated) {
            $spec['deprecated'] = true;
        }

        // Add request body for POST/PUT/PATCH
        $requestBody = $this->extractRequestBody($reflection, $route);
        if ($requestBody) {
            $spec['requestBody'] = $requestBody;
        }

        return $spec;
    }

    /**
     * Generate summary from method name.
     */
    protected function generateSummary(ReflectionMethod $reflection): string
    {
        $name = $reflection->getName();
        // Convert camelCase to words
        $words = preg_replace('/([a-z])([A-Z])/', '$1 $2', $name);

        return ucfirst($words);
    }

    /**
     * Generate description from docblock.
     */
    protected function generateDescription(ReflectionMethod $reflection): string
    {
        $docComment = $reflection->getDocComment();
        if (! $docComment) {
            return '';
        }

        // Extract first paragraph from docblock
        preg_match('/\/\*\*\s*\n\s*\*\s*(.+?)(?:\n\s*\*\s*\n|\n\s*\*\s*@)/s', $docComment, $matches);

        if (isset($matches[1])) {
            return trim(preg_replace('/\s*\n\s*\*\s*/', ' ', $matches[1]));
        }

        return '';
    }

    /**
     * Generate operation ID.
     */
    protected function generateOperationId(Route $route, ReflectionMethod $reflection): string
    {
        $className = class_basename($reflection->getDeclaringClass()->getName());
        $methodName = $reflection->getName();

        return lcfirst(str_replace('Controller', '', $className)) . ucfirst($methodName);
    }

    /**
     * Infer tags from route.
     */
    protected function inferTags(Route $route): array
    {
        $uri = $route->uri();
        $parts = explode('/', trim($uri, '/'));

        // Skip 'api' prefix
        if (($parts[0] ?? '') === 'api') {
            array_shift($parts);
        }

        if (! empty($parts[0])) {
            return [ucfirst($parts[0])];
        }

        return ['Default'];
    }

    /**
     * Extract parameters from route and attributes.
     */
    protected function extractParameters(Route $route, ReflectionMethod $reflection): array
    {
        $parameters = [];

        // Extract path parameters from route
        preg_match_all('/\{(\w+)\??\}/', $route->uri(), $matches);
        foreach ($matches[1] as $param) {
            $parameters[] = [
                'name' => $param,
                'in' => 'path',
                'required' => ! str_contains($route->uri(), '{' . $param . '?}'),
                'schema' => ['type' => 'string'],
                'description' => ucfirst($param) . ' parameter',
            ];
        }

        // Extract from ApiRequest attributes
        $requestAttributes = $reflection->getAttributes(ApiRequest::class);
        foreach ($requestAttributes as $attr) {
            $request = $attr->newInstance();
            $param = [
                'name' => $request->name,
                'in' => $request->in,
                'required' => $request->required,
                'schema' => ['type' => $request->type],
            ];

            if ($request->description) {
                $param['description'] = $request->description;
            }

            if ($request->example !== null) {
                $param['example'] = $request->example;
            }

            $parameters[] = $param;
        }

        return $parameters;
    }

    /**
     * Extract request body from attributes.
     */
    protected function extractRequestBody(ReflectionMethod $reflection, Route $route): ?array
    {
        $methods = array_map('strtoupper', $route->methods());
        $needsBody = array_intersect($methods, ['POST', 'PUT', 'PATCH']);

        if (empty($needsBody)) {
            return null;
        }

        $attributes = $reflection->getAttributes(ApiRequestBody::class);

        if (! empty($attributes)) {
            $body = $attributes[0]->newInstance();

            $schema = [
                'type' => 'object',
                'properties' => [],
            ];

            foreach ($body->properties as $name => $type) {
                $schema['properties'][$name] = $this->parsePropertyType($type);
            }

            if (! empty($body->required)) {
                $schema['required'] = $body->required;
            }

            $requestBody = [
                'required' => true,
                'content' => [
                    'application/json' => [
                        'schema' => $schema,
                    ],
                ],
            ];

            if ($body->description) {
                $requestBody['description'] = $body->description;
            }

            if ($body->example) {
                $requestBody['content']['application/json']['example'] = $body->example;
            }

            return $requestBody;
        }

        // Auto-generate basic request body for POST/PUT/PATCH
        return [
            'required' => false,
            'content' => [
                'application/json' => [
                    'schema' => [
                        'type' => 'object',
                        'additionalProperties' => true,
                    ],
                ],
            ],
        ];
    }

    /**
     * Parse property type to OpenAPI schema.
     */
    protected function parsePropertyType(mixed $type): array
    {
        if (is_array($type)) {
            return $type;
        }

        return match ($type) {
            'int', 'integer' => ['type' => 'integer'],
            'float', 'double', 'number' => ['type' => 'number'],
            'bool', 'boolean' => ['type' => 'boolean'],
            'array' => ['type' => 'array', 'items' => ['type' => 'string']],
            'object' => ['type' => 'object'],
            default => ['type' => 'string'],
        };
    }

    /**
     * Extract responses from attributes or infer from method.
     */
    protected function extractResponses(ReflectionMethod $reflection, Route $route): array
    {
        $responses = [];

        // Check for ApiResponse attributes
        $responseAttributes = $reflection->getAttributes(ApiResponse::class);

        if (! empty($responseAttributes)) {
            foreach ($responseAttributes as $attr) {
                $response = $attr->newInstance();
                $responses[(string) $response->status] = $this->buildResponseSpec($response);
            }
        }

        // Auto-infer responses if none specified
        if (empty($responses)) {
            $responses = $this->inferResponses($reflection, $route);
        }

        return $responses;
    }

    /**
     * Build response specification.
     */
    protected function buildResponseSpec(ApiResponse $response): array
    {
        $spec = [
            'description' => $response->description,
        ];

        if ($response->ref) {
            $spec['content'] = [
                'application/json' => [
                    'schema' => ['$ref' => '#/components/schemas/' . $response->ref],
                ],
            ];
        } elseif ($response->example) {
            $spec['content'] = [
                'application/json' => [
                    'schema' => ['type' => 'object'],
                    'example' => $response->example,
                ],
            ];
        } else {
            $schemaRef = $this->getSchemaRefForStatus($response->status);
            $spec['content'] = [
                'application/json' => [
                    'schema' => ['$ref' => '#/components/schemas/' . $schemaRef],
                ],
            ];
        }

        return $spec;
    }

    /**
     * Get schema reference for status code.
     */
    protected function getSchemaRefForStatus(int $status): string
    {
        return match (true) {
            $status >= 200 && $status < 300 => 'SuccessResponse',
            $status === 422 => 'ValidationErrorResponse',
            $status >= 400 => 'ErrorResponse',
            default => 'SuccessResponse',
        };
    }

    /**
     * Infer responses from method analysis.
     */
    protected function inferResponses(ReflectionMethod $reflection, Route $route): array
    {
        $methodName = strtolower($reflection->getName());
        $httpMethods = array_map('strtoupper', $route->methods());

        // Analyze method name and HTTP method to infer responses
        $responses = [];

        // Success response based on method name
        if (str_contains($methodName, 'store') || str_contains($methodName, 'create')) {
            $responses['201'] = [
                'description' => 'Resource created successfully',
                'content' => [
                    'application/json' => [
                        'schema' => ['$ref' => '#/components/schemas/SuccessResponse'],
                    ],
                ],
            ];
        } elseif (str_contains($methodName, 'destroy') || str_contains($methodName, 'delete')) {
            $responses['204'] = [
                'description' => 'Resource deleted successfully',
            ];
        } elseif (str_contains($methodName, 'paginate')) {
            $responses['200'] = [
                'description' => 'Paginated results',
                'content' => [
                    'application/json' => [
                        'schema' => ['$ref' => '#/components/schemas/PaginatedResponse'],
                    ],
                ],
            ];
        } else {
            $responses['200'] = [
                'description' => 'Successful response',
                'content' => [
                    'application/json' => [
                        'schema' => ['$ref' => '#/components/schemas/SuccessResponse'],
                    ],
                ],
            ];
        }

        // Add common error responses
        if (str_contains($methodName, 'validation') || in_array('POST', $httpMethods) || in_array('PUT', $httpMethods)) {
            $responses['422'] = [
                'description' => 'Validation error',
                'content' => [
                    'application/json' => [
                        'schema' => ['$ref' => '#/components/schemas/ValidationErrorResponse'],
                    ],
                ],
            ];
        }

        if (str_contains($methodName, 'unauthorized')) {
            $responses['401'] = [
                'description' => 'Unauthorized',
                'content' => [
                    'application/json' => [
                        'schema' => ['$ref' => '#/components/schemas/ErrorResponse'],
                    ],
                ],
            ];
        }

        if (str_contains($methodName, 'forbidden')) {
            $responses['403'] = [
                'description' => 'Forbidden',
                'content' => [
                    'application/json' => [
                        'schema' => ['$ref' => '#/components/schemas/ErrorResponse'],
                    ],
                ],
            ];
        }

        if (str_contains($methodName, 'notfound') || str_contains($methodName, 'not_found')) {
            $responses['404'] = [
                'description' => 'Resource not found',
                'content' => [
                    'application/json' => [
                        'schema' => ['$ref' => '#/components/schemas/ErrorResponse'],
                    ],
                ],
            ];
        }

        if (str_contains($methodName, 'badrequest') || str_contains($methodName, 'bad_request')) {
            $responses['400'] = [
                'description' => 'Bad request',
                'content' => [
                    'application/json' => [
                        'schema' => ['$ref' => '#/components/schemas/ErrorResponse'],
                    ],
                ],
            ];
        }

        if (str_contains($methodName, 'servererror') || str_contains($methodName, 'server_error')) {
            $responses['500'] = [
                'description' => 'Internal server error',
                'content' => [
                    'application/json' => [
                        'schema' => ['$ref' => '#/components/schemas/ErrorResponse'],
                    ],
                ],
            ];
        }

        if (str_contains($methodName, 'ratelimit') || str_contains($methodName, 'rate_limit')) {
            $responses['429'] = [
                'description' => 'Too many requests',
                'content' => [
                    'application/json' => [
                        'schema' => ['$ref' => '#/components/schemas/ErrorResponse'],
                    ],
                ],
            ];
        }

        if (str_contains($methodName, 'conflict')) {
            $responses['409'] = [
                'description' => 'Conflict',
                'content' => [
                    'application/json' => [
                        'schema' => ['$ref' => '#/components/schemas/ErrorResponse'],
                    ],
                ],
            ];
        }

        if (str_contains($methodName, 'async') || str_contains($methodName, 'accepted')) {
            $responses['202'] = [
                'description' => 'Request accepted for processing',
                'content' => [
                    'application/json' => [
                        'schema' => ['$ref' => '#/components/schemas/SuccessResponse'],
                    ],
                ],
            ];
        }

        return $responses;
    }
}
